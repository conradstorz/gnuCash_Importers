"""
This is a working process as of 8/6/2025
I believe this is the final version of the script
I had considered adding the posting data but I think it is better to leave that to gnuCash
When I tried to include the posting date and posting account it caused issues with the import that I could not resolve.
As I have discovered through out this process the documentation, wiki, and examples are full of errors and omissions.
This script is designed to prepare vendor, account, and bill CSVs for GnuCash import and it works for that much.

I believe at this point that the import functions of gnuCash are very poorly implemented and not well documented and riddled with bugs.
I have spent many hours trying to get the import to work with the posting data and it just does not work.
Looking at the various community examples and the documentation I have found that many of the examples are incorrect or incomplete.
I have tried to follow the examples and documentation but it is just not working.
Discussions on the GnuCash forums and other community sites indicate that many users have similar issues with the import functions.
I have decided to leave the posting data out of the import and just use the unposted bills.
Discussions are also getting old and the active developers are seeming to be just overwhelmed with the issues.
I have decided to just use the unposted bills and let GnuCash handle the posting. -Conrad 8/8/2025
"""
import csv
import argparse
from pathlib import Path
from datetime import date, datetime
from loguru import logger
from piecash import open_book
import uuid
import string
import warnings
from sqlalchemy.exc import SAWarning

# Filter irrelevant SQLAlchemy warnings
warnings.filterwarnings("ignore", category=SAWarning, module="piecash")

# --- Constants ---
DEFAULT_DB = None
DEFAULT_INPUT = "raw_bills.csv"
DEFAULT_VENDOR_PREFIX = "unknown_vendors_"
DEFAULT_ACCOUNT_PREFIX = "unknown_accounts_"
DEFAULT_ACCOUNT_FALLBACK = "MISC EXPENSE"
DEFAULT_ACCOUNT_PARENT = "Expenses"
DEFAULT_AP_ACCOUNT = "Liabilities:Accounts Payable"
TODAY = date.today().isoformat()

BILL_FIELDS = [
    "id", "date_opened", "owner_id", "billingid", "notes", "date", "desc", "action",
    "account", "quantity", "price", "disc_type", "disc_how", "discount",
    "taxable", "taxincluded", "tax_table", "date_posted", "due_date",
    "account_posted", "memo_posted", "accu_splits"
]
VENDOR_FIELDS = [
    "id", "company", "name", "addr1", "addr2", "addr3", "addr4",
    "phone", "fax", "email", "notes", "shipname", "shipaddr1",
    "shipaddr2", "shipaddr3", "shipaddr4", "shiphone", "shipfax", "shipmail"
]
"""
# GnuCash Account Template
This is a template for GnuCash accounts that can be used to create a new accounts CSV
This file was generated by the export feature of gnuCash

Type,Full Account Name,Account Name,Account Code,Description,Account Color,Notes,Symbol,Namespace,Hidden,Tax Info,Placeholder
CASH,Cash Accounts,Cash Accounts,,,,,USD,CURRENCY,F,F,F
CASH,Cash Accounts:ATM VAULTS,ATM VAULTS,,,,,USD,CURRENCY,F,F,F
CASH,Cash Accounts:Checking,Checking,,,,,USD,CURRENCY,F,F,F
CASH,Cash Accounts:Petty Cash,Petty Cash,,,,,USD,CURRENCY,F,F,F
BANK,Cash Accounts:Savings,Savings,,,,,USD,CURRENCY,F,F,F
CASH,Petty Cash,Petty Cash,,,,,USD,CURRENCY,F,F,F
LIABILITY,SBA_EIDL,SBA_EIDL,,,,,USD,CURRENCY,F,F,F
INCOME,Sales,Sales,,,,,USD,CURRENCY,F,F,F
EXPENSE,Rent Paid,Rent Paid,,,,,USD,CURRENCY,F,F,F
EXPENSE,Rent Paid:Office Building,Office Building,,,,,USD,CURRENCY,F,F,F
EXPENSE,Rent Paid:Software Rental,Software Rental,,,,,USD,CURRENCY,F,F,F
EXPENSE,Utilities,Utilities,,,,,USD,CURRENCY,F,F,F
EQUITY,Equity,Equity,,,,,USD,CURRENCY,F,F,F
EQUITY,Equity:Furniture and Equipment,Furniture and Equipment,,,,,USD,CURRENCY,F,F,F
EQUITY,Owners Draw/Invest,Owners Draw/Invest,,,,,USD,CURRENCY,F,F,F
BANK,Bank account 4554000327,Bank account 4554000327,,Savings,,,USD,CURRENCY,F,F,F
CASH,Bank account 4554000327:Destination account for the auto-balance split.,Destination account for the auto-balance split.,,Income,,,USD,CURRENCY,F,F,F
BANK,Imbalance-USD,Imbalance-USD,,,,,USD,CURRENCY,F,F,F
"""

# --- Utility Functions ---
def find_gnucash_db() -> Path | None:
    files = sorted(Path.cwd().glob("*.gnucash"))
    if len(files) == 1:
        return files[0]
    elif len(files) > 1:
        logger.warning("Multiple GnuCash files found. Please specify with --db.")
    else:
        logger.error("No GnuCash .gnucash database file found in current directory.")
    return None

def is_xml_file(file_path: Path) -> bool:
    try:
        with file_path.open("rb") as f:
            head = f.read(64).lower()
            return b"<?xml" in head or b"<gnucash" in head
    except Exception as e:
        logger.warning(f"Could not read file to check XML format: {e}")
        return False

def safe_date(value: str) -> str:
    # This function must return the date format that matched the format used in the live GnuCash database
    if not value.strip():
        return date.today().isoformat()  # Default to today if empty 
    try: 
        ds = datetime.strptime(value.strip(), "%m/%d/%Y").date().isoformat()
        return ds
    except Exception:
        today = date.today()
        custom_string = today.strftime("%m/%d/%Y")
        return custom_string

def generate_sequential_id(index: int) -> str:
    """
    Given a zero-based index, return a string like '20250805A', '20250805B', …
    Rolls over to two letters if you exceed 26 (e.g. '20250805AA').
    """
    date_str = datetime.now().strftime("%Y%m%d")
    # Convert index to a base-26 “letter” sequence (A, B, …, Z, AA, AB, …)
    letters = []
    i = index
    while True:
        letters.append(string.ascii_uppercase[i % 26])
        i = i // 26 - 1
        if i < 0:
            break
    suffix = ''.join(reversed(letters))
    return f"{date_str}{suffix}"

def load_gnucash_data(db_path: Path):
    if is_xml_file(db_path):
        raise RuntimeError(
            f"Unsupported GnuCash XML format detected at {db_path}.\n"
            f"To convert: open the file in GnuCash, then File → Save As… → SQLite."
        )
    with open_book(db_path, readonly=True) as book:
        # build a dict from lower-cased vendor names → vendor numbers
        vendors = {
            v.name.strip().lower(): v.id
            for v in book.vendors
        }
        accounts = {a.fullname.strip().lower(): a.fullname.strip() for a in book.accounts}
    return vendors, accounts

def write_csv(path: Path, headers: list[str], rows: list[dict]):
    # Write semicolon-separated CSV for GnuCash compatibility
    with path.open("w", newline="", encoding="utf-8") as f:
        writer = csv.DictWriter(f, fieldnames=headers, delimiter=';')
        writer.writeheader()
        writer.writerows(rows)

# New header matching GnuCash’s export template:
ACCOUNT_CSV_HEADER = [
    "Type",
    "Full Account Name",
    "Account Name",
    "Account Code",
    "Description",
    "Account Color",
    "Notes",
    "Symbol",
    "Namespace",
    "Hidden",
    "Tax Info",
    "Placeholder",
] #Type,Full Account Name,Account Name,Account Code,Description,Account Color,Notes,Symbol,Namespace,Hidden,Tax Info,Placeholder

def write_accounts_csv(unknown_accounts: list[str]):
    if not unknown_accounts:
        return None

    output = Path(f"{DEFAULT_ACCOUNT_PREFIX}{date.today():%Y%m%d}.csv")

    with output.open("w", newline="", encoding="utf-8") as f:
        # Write semicolon-separated CSV for unknown accounts
        writer = csv.writer(f, delimiter=';')
        writer.writerow(ACCOUNT_CSV_HEADER)

        for name in unknown_accounts:
            full_name = f"{DEFAULT_ACCOUNT_PARENT}:{name}"
            # You can adjust Account Code / Namespace / Tax Info etc. to match your chart
            writer.writerow([
                "EXPENSE",                  # Type
                full_name,                 # Full Account Name
                name,                      # Account Name
                "",                        # Account Code
                f"Auto-generated account for {name}",  # Description
                "", "", "USD", "CURRENCY", "F", "F", "F"
            ])

    logger.info(f"Wrote new accounts import file: {output}")
    return output

def write_vendors_csv(unknown_vendors: list[str]):
    if not unknown_vendors:
        return None

    output = Path(f"{DEFAULT_VENDOR_PREFIX}{date.today():%Y%m%d}.csv")
    vendor_rows = []
    for name in unknown_vendors:
        vendor_rows.append({field: "" for field in VENDOR_FIELDS} | {
            "company": name,
            "name": "unknown contact"
        })

    with output.open("w", newline="", encoding="utf-8") as f:
        # Write semicolon-separated CSV for unknown vendors
        writer = csv.DictWriter(f, fieldnames=VENDOR_FIELDS, delimiter=';')
        writer.writeheader()
        writer.writerows(vendor_rows)

    logger.info(f"Wrote new vendors import file: {output}")
    return output

def match_account(name: str, account_lookup: dict) -> str:
    key = name.strip().lower()
    if key in account_lookup:
        return account_lookup[key]
    for k, v in account_lookup.items():
        if key in k:
            logger.warning(f"Partial match found for account '{name}': using '{v}'")
            return v
    logger.warning(f"Account '{name}' not found. Using fallback '{DEFAULT_ACCOUNT_FALLBACK}'")
    return DEFAULT_ACCOUNT_FALLBACK

def process_bills(input_path: Path, db_path: Path):
    vendor_lookup, account_lookup = load_gnucash_data(db_path)
    unknown_vendors = set()
    unknown_accounts = set()
    bills = []

    with input_path.open(newline='', encoding="utf-8") as f:
        reader = csv.DictReader(f, delimiter=';')  # Enforce semicolon-separated input
        for idx, row in enumerate(reader):
            vendor_name = row.get("vendor name", "").strip()
            if not vendor_name:
                logger.warning(f"Skipping row with missing vendor: {row}")
                continue

            account_name = row.get("account", "").strip()
            vendor_key = vendor_name.lower()

            if vendor_key not in vendor_lookup:
                unknown_vendors.add(vendor_name)

            matched_account = match_account(account_name, account_lookup)
            if matched_account == DEFAULT_ACCOUNT_FALLBACK:
                unknown_accounts.add(account_name)

            vendor_key = vendor_name.strip().lower()
            vendor_no = vendor_lookup.get(vendor_key, "")  # empty or default if not found

            bill_row = {
                "id": generate_sequential_id(idx),
                "date_opened": safe_date(row.get("date", "")),
                "owner_id": vendor_no,
                "billingid": "",
                "notes": "",
                "date": safe_date(row.get("date", "")),
                "desc": row.get("description", "").strip(),
                "action": "",
                "account": account_name, #matched_account,
                "quantity": row.get("quantity", "1"),
                "price": row.get("amount", "0"),
                "disc_type": "", "disc_how": "", "discount": "",
                "taxable": "", "taxincluded": "", "tax_table": "",
                "date_posted": "",  # Unposted for now
                "due_date": "",
                "account_posted": "",
                "memo_posted": "", "accu_splits": ""
            }
            bills.append(bill_row)

    vendor_file = write_vendors_csv(sorted(unknown_vendors))
    account_file = write_accounts_csv(sorted(unknown_accounts))

    if vendor_file:
        logger.warning("Vendor records are missing. Skipping bill import CSV generation.")
        logger.info("Please import the vendor file into GnuCash first.")
        if account_file:
            logger.info("You may also import the accounts file now.")
        return

    # All vendors exist; write bills (semicolon-separated)
    bill_output = Path(f"bills_{TODAY}.csv")

    # Write semicolon-separated CSV for bills without header
    with bill_output.open("w", newline="", encoding="utf-8") as f:
        writer = csv.DictWriter(f, fieldnames=BILL_FIELDS, delimiter=';')
        writer.writerows(bills)

    logger.success(f"Bill import file generated: {bill_output}")
    
    if account_file:
        logger.info("Additional accounts file also created (optional import).")
    logger.info("You may now import the bills CSV into GnuCash.")

# --- Entry Point ---
def main():
    parser = argparse.ArgumentParser(description="Prepare vendor, account, and bill CSVs for GnuCash import.")
    parser.add_argument("--db", type=Path, help="Path to GnuCash SQLite file (default: auto-detect)")
    parser.add_argument("--input", type=Path, default=Path(DEFAULT_INPUT), help="Raw bills CSV file")
    args = parser.parse_args()

    logger.add("prepare_gnucash_imports.log", rotation="500 KB")
    db_path = args.db or find_gnucash_db()
    if not db_path:
        logger.error("GnuCash database file not found or specified. Aborting.")
        return

    process_bills(args.input, db_path)

if __name__ == "__main__":
    main()
